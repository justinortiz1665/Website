import fs from "fs"
import path from "path"
import matter from "gray-matter"
import { remark } from "remark"
import html from "remark-html"

// Define the content directory path
const contentDirectory = path.join(process.cwd(), "content")
const projectsDirectory = path.join(contentDirectory, "projects")

// Add image metadata interface
export interface ImageMetadata {
  src: string
  alt?: string
  aspectRatio?: "1:1" | "4:5" | "16:9" | string
  width?: number
  height?: number
  caption?: string
}

// Define the Project interface based on frontmatter
export interface ProjectFeature {
  title: string
  description: string
}

export interface ProjectSection {
  title: string
  content: string
  type?: "text" | "gallery" | "quote" | "code" | string
}

export interface ProjectFrontmatter {
  slug: string
  title: string
  date: string
  summary?: string
  problem?: string
  solution?: string
  // Replace simple image string with ImageMetadata or string
  image?: string | ImageMetadata
  // Add support for multiple images
  images?: (string | ImageMetadata)[]
  // Add a featured image specifically for thumbnails (1:1 ratio)
  thumbnail?: string | ImageMetadata
  tags?: string[]
  features?: ProjectFeature[]
  youtubeId?: string
  // Add support for custom sections
  sections?: ProjectSection[]
  // Add a flexible metadata field for any additional data
  metadata?: Record<string, any>
  // Allow for any other custom fields
  [key: string]: any
}

export interface Project extends ProjectFrontmatter {
  content: string
}

// Get all project slugs
export function getProjectSlugs(): string[] {
  try {
    // Check if content directory exists
    if (!fs.existsSync(contentDirectory)) {
      console.log("Content directory does not exist:", contentDirectory)
      fs.mkdirSync(contentDirectory, { recursive: true })
    }

    // Check if projects directory exists
    if (!fs.existsSync(projectsDirectory)) {
      console.log("Projects directory does not exist:", projectsDirectory)
      fs.mkdirSync(projectsDirectory, { recursive: true })
      return []
    }

    const files = fs.readdirSync(projectsDirectory)
    return files.filter((file) => file.endsWith(".md")).map((file) => file.replace(/\.md$/, ""))
  } catch (error) {
    console.error("Error reading project directory:", error)
    return []
  }
}

// Get project data by slug with enhanced flexibility
export function getProjectBySlug(slug: string): Project | null {
  try {
    const fullPath = path.join(projectsDirectory, `${slug}.md`)

    if (!fs.existsSync(fullPath)) {
      return null
    }

    const fileContents = fs.readFileSync(fullPath, "utf8")
    const { data, content } = matter(fileContents)

    // Create a base project with required fields
    const project: Project = {
      slug,
      title: data.title || "Untitled Project",
      date: data.date || new Date().toISOString().split("T")[0],
      content,
    }

    // Process image data to ensure proper format
    if (data.image && typeof data.image === "string") {
      // Convert string image to ImageMetadata with 1:1 aspect ratio for thumbnails
      project.image = {
        src: data.image,
        aspectRatio: "1:1",
      }
    } else if (data.image) {
      // If it's already an object, ensure it has aspectRatio
      project.image = {
        ...data.image,
        aspectRatio: data.image.aspectRatio || "1:1",
      }
    }

    // Process thumbnail specifically for 1:1 display
    if (data.thumbnail && typeof data.thumbnail === "string") {
      project.thumbnail = {
        src: data.thumbnail,
        aspectRatio: "1:1",
      }
    } else if (data.thumbnail) {
      project.thumbnail = {
        ...data.thumbnail,
        aspectRatio: "1:1", // Force 1:1 for thumbnails
      }
    } else if (project.image) {
      // If no thumbnail is specified, use the main image as thumbnail
      project.thumbnail =
        typeof project.image === "string"
          ? { src: project.image, aspectRatio: "1:1" }
          : { ...project.image, aspectRatio: "1:1" }
    }

    // Add all other frontmatter fields dynamically
    Object.keys(data).forEach((key) => {
      if (!["title", "date", "image", "thumbnail"].includes(key)) {
        project[key as keyof Project] = data[key]
      }
    })

    return project
  } catch (error) {
    console.error(`Error reading project ${slug}:`, error)
    return null
  }
}

// Get image URL with proper aspect ratio
export function getImageUrl(image: string | ImageMetadata | undefined, defaultRatio = "1:1"): string {
  if (!image) return `/placeholder.svg?height=600&width=600`

  if (typeof image === "string") {
    // For placeholder images, enforce the aspect ratio
    if (image.includes("placeholder.svg")) {
      return `/placeholder.svg?height=600&width=600` // Always 1:1 for consistency
    }
    return image
  }

  // If it's an ImageMetadata object
  if (image.src) {
    // For placeholder images, enforce the aspect ratio
    if (image.src.includes("placeholder.svg")) {
      return `/placeholder.svg?height=600&width=600` // Always 1:1 for consistency
    }
    return image.src
  }

  return `/placeholder.svg?height=600&width=600`
}

// Helper function to get dimensions from aspect ratio
export function getAspectRatioDimensions(aspectRatio: string, baseSize: number): [number, number] {
  if (!aspectRatio.includes(":")) {
    return [baseSize, baseSize] // Default to square
  }

  const [widthRatio, heightRatio] = aspectRatio.split(":").map(Number)

  if (widthRatio === heightRatio) {
    return [baseSize, baseSize] // 1:1 ratio
  }

  if (widthRatio > heightRatio) {
    // Landscape
    const height = Math.round(baseSize * (heightRatio / widthRatio))
    return [baseSize, height]
  } else {
    // Portrait
    const width = Math.round(baseSize * (widthRatio / heightRatio))
    return [width, baseSize]
  }
}

// Get all projects
export function getAllProjects(): Project[] {
  try {
    const slugs = getProjectSlugs()

    // If no project files are found, return the sample projects
    if (slugs.length === 0) {
      console.log("No markdown project files found, using sample projects")
      return getSampleProjects()
    }

    const projects = slugs
      .map((slug) => getProjectBySlug(slug))
      .filter((project): project is Project => project !== null)
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())

    return projects.length > 0 ? projects : getSampleProjects()
  } catch (error) {
    console.error("Error getting all projects:", error)
    return getSampleProjects()
  }
}

// Get all unique tags from all projects
export function getAllTags(): string[] {
  const projects = getAllProjects()
  const tagsSet = new Set<string>()

  projects.forEach((project) => {
    if (project.tags) {
      project.tags.forEach((tag) => {
        tagsSet.add(tag)
      })
    }
  })

  return Array.from(tagsSet).sort()
}

// Get projects by tag
export function getProjectsByTag(tag: string): Project[] {
  const allProjects = getAllProjects()
  return allProjects.filter((project) => project.tags && project.tags.includes(tag))
}

// Get projects by any custom field
export function getProjectsByField(fieldName: string, value: any): Project[] {
  const allProjects = getAllProjects()
  return allProjects.filter((project) => project[fieldName as keyof Project] === value)
}

// Get projects by search query (searches in title, summary, and content)
export function searchProjects(query: string): Project[] {
  const allProjects = getAllProjects()
  const searchTerm = query.toLowerCase()

  return allProjects.filter((project) => {
    const titleMatch = project.title.toLowerCase().includes(searchTerm)
    const summaryMatch = project.summary ? project.summary.toLowerCase().includes(searchTerm) : false
    const contentMatch = project.content.toLowerCase().includes(searchTerm)

    return titleMatch || summaryMatch || contentMatch
  })
}

// Convert markdown content to HTML with options
export async function markdownToHtml(
  markdown: string,
  options: {
    removeHeadings?: boolean
    excerpt?: boolean
    excerptLength?: number
  } = {},
): Promise<string> {
  let processedMarkdown = markdown

  // Option to remove headings (useful for excerpts)
  if (options.removeHeadings) {
    processedMarkdown = processedMarkdown.replace(/^#{1,6}\s+.+$/gm, "")
  }

  // Option to get only an excerpt
  if (options.excerpt) {
    const length = options.excerptLength || 150
    // Remove markdown formatting for cleaner excerpts
    const plainText = processedMarkdown.replace(/[#*_~`]/g, "")
    processedMarkdown = plainText.slice(0, length)

    // Don't cut words in half
    if (processedMarkdown.length === length) {
      const lastSpaceIndex = processedMarkdown.lastIndexOf(" ")
      if (lastSpaceIndex > length * 0.8) {
        // Only trim if we're not cutting too much
        processedMarkdown = processedMarkdown.slice(0, lastSpaceIndex)
      }
    }

    processedMarkdown += "..."
  }

  const result = await remark().use(html).process(processedMarkdown)

  return result.toString()
}

// Get a project template
export function getProjectTemplate(templateName: string): Project | null {
  const templatesDirectory = path.join(contentDirectory, "templates")

  try {
    if (!fs.existsSync(templatesDirectory)) {
      return null
    }

    const templatePath = path.join(templatesDirectory, `${templateName}.md`)

    if (!fs.existsSync(templatePath)) {
      return null
    }

    const fileContents = fs.readFileSync(templatePath, "utf8")
    const { data, content } = matter(fileContents)

    return {
      slug: "template",
      title: data.title || "Template",
      date: data.date || new Date().toISOString().split("T")[0],
      ...data,
      content,
    }
  } catch (error) {
    console.error(`Error reading template ${templateName}:`, error)
    return null
  }
}

// Create a new project from template or defaults
export function createProject(slug: string, data: Partial<ProjectFrontmatter>, content = ""): boolean {
  try {
    const fullPath = path.join(projectsDirectory, `${slug}.md`)

    // Don't overwrite existing projects
    if (fs.existsSync(fullPath)) {
      return false
    }

    // Ensure required fields
    const projectData = {
      title: data.title || "Untitled Project",
      date: data.date || new Date().toISOString().split("T")[0],
      ...data,
    }

    // Create frontmatter
    const frontmatter = matter.stringify(content, projectData)

    // Ensure projects directory exists
    if (!fs.existsSync(projectsDirectory)) {
      fs.mkdirSync(projectsDirectory, { recursive: true })
    }

    // Write the file
    fs.writeFileSync(fullPath, frontmatter)

    return true
  } catch (error) {
    console.error(`Error creating project ${slug}:`, error)
    return false
  }
}

// Validate a project
export function validateProject(project: Partial<Project>): {
  valid: boolean
  errors: string[]
} {
  const errors: string[] = []

  // Check required fields
  if (!project.title) errors.push("Title is required")
  if (!project.date) errors.push("Date is required")

  // Validate date format
  if (project.date && !/^\d{4}-\d{2}-\d{2}$/.test(project.date)) {
    errors.push("Date must be in YYYY-MM-DD format")
  }

  // Validate image path if provided
  if (project.image) {
    if (typeof project.image === "string") {
      if (!project.image.startsWith("/")) {
        errors.push("Image path should start with /")
      }
    } else if (project.image.src && !project.image.src.startsWith("/")) {
      errors.push("Image src should start with /")
    }
  }

  // Validate features if provided
  if (project.features && Array.isArray(project.features)) {
    project.features.forEach((feature, index) => {
      if (!feature.title) {
        errors.push(`Feature ${index + 1} is missing a title`)
      }
      if (!feature.description) {
        errors.push(`Feature ${index + 1} is missing a description`)
      }
    })
  }

  // Validate sections if provided
  if (project.sections && Array.isArray(project.sections)) {
    project.sections.forEach((section, index) => {
      if (!section.title) {
        errors.push(`Section ${index + 1} is missing a title`)
      }
      if (!section.content) {
        errors.push(`Section ${index + 1} is missing content`)
      }
    })
  }

  return {
    valid: errors.length === 0,
    errors,
  }
}

// Get related projects based on tags
export function getRelatedProjects(project: Project, limit = 3): Project[] {
  if (!project.tags || project.tags.length === 0) {
    return []
  }

  const allProjects = getAllProjects()

  // Filter out the current project
  const otherProjects = allProjects.filter((p) => p.slug !== project.slug)

  // Calculate relevance score based on tag matches
  const projectsWithScore = otherProjects.map((p) => {
    let score = 0
    if (p.tags) {
      // Count matching tags
      project.tags!.forEach((tag) => {
        if (p.tags!.includes(tag)) {
          score++
        }
      })
    }
    return { project: p, score }
  })

  // Sort by score (highest first) and take the top 'limit' projects
  return projectsWithScore
    .sort((a, b) => b.score - a.score)
    .filter((item) => item.score > 0) // Only include projects with at least one matching tag
    .slice(0, limit)
    .map((item) => item.project)
}

// Provide sample projects when no markdown files are found
function getSampleProjects(): Project[] {
  return [
    {
      slug: "rehabilitation-program",
      title: "ACL Rehabilitation Program",
      date: "2023-05-15",
      summary:
        "A comprehensive rehabilitation protocol designed for athletes recovering from ACL reconstruction surgery, focusing on progressive strength building, mobility restoration, and safe return to sport.",
      problem:
        "Athletes recovering from ACL reconstruction often face challenges with inconsistent rehabilitation approaches, unclear progression criteria, and high re-injury rates due to premature return to sport.",
      solution:
        "This program provides a structured, evidence-based rehabilitation protocol with clear progression milestones, objective testing criteria, and sport-specific training to ensure optimal recovery and minimize re-injury risk.",
      image: {
        src: "/placeholder.svg?height=600&width=600",
        aspectRatio: "1:1",
      },
      tags: ["Rehabilitation", "Sports Medicine", "Protocol"],
      features: [
        {
          title: "Phase-Based Progression",
          description: "Clearly defined rehabilitation phases with specific goals and criteria for advancement.",
        },
        {
          title: "Objective Testing Protocols",
          description: "Standardized assessments to measure strength, stability, and functional performance.",
        },
        {
          title: "Sport-Specific Training",
          description: "Customized exercises that replicate the demands of the athlete's specific sport.",
        },
        {
          title: "Psychological Readiness",
          description: "Tools to assess and address psychological barriers to return to sport.",
        },
      ],
      youtubeId: "dQw4w9WgXcQ",
      content: "Sample content for ACL Rehabilitation Program",
    },
    {
      slug: "injury-prevention",
      title: "Injury Prevention Workshop",
      date: "2023-08-22",
      summary:
        "An educational program designed for high school athletes to reduce injury risk through proper movement patterns, strength training, and recovery strategies.",
      problem:
        "High school athletes often lack proper education on injury prevention, leading to higher rates of preventable injuries and potentially affecting their athletic development and long-term health.",
      solution:
        "This workshop provides comprehensive education on biomechanics, movement screening, corrective exercises, and recovery strategies tailored specifically for adolescent athletes and their unique developmental needs.",
      image: {
        src: "/placeholder.svg?height=600&width=600",
        aspectRatio: "1:1",
      },
      tags: ["Education", "Prevention", "Youth"],
      features: [
        {
          title: "Movement Screening",
          description: "Assessment tools to identify movement deficiencies and injury risk factors.",
        },
        {
          title: "Corrective Exercise Library",
          description: "Targeted exercises to address common movement dysfunctions in young athletes.",
        },
        {
          title: "Coach Education",
          description: "Resources for coaches to implement injury prevention strategies in team practices.",
        },
        {
          title: "Recovery Protocols",
          description: "Age-appropriate recovery strategies to prevent overtraining and burnout.",
        },
      ],
      youtubeId: "dQw4w9WgXcQ",
      content: "Sample content for Injury Prevention Workshop",
    },
    {
      slug: "performance-analytics",
      title: "Performance Analytics Dashboard",
      date: "2023-11-10",
      summary:
        "A data-driven approach to athlete monitoring and performance optimization, tracking key metrics to inform training decisions and maximize athletic potential.",
      problem:
        "Coaches and athletic trainers often lack accessible, comprehensive data on athlete performance, making it difficult to make informed decisions about training loads, recovery needs, and performance optimization.",
      solution:
        "This analytics dashboard aggregates data from multiple sources to provide actionable insights on athlete readiness, training response, and performance trends, enabling more personalized and effective training programs.",
      image: {
        src: "/placeholder.svg?height=600&width=600",
        aspectRatio: "1:1",
      },
      tags: ["Analytics", "Technology", "Performance"],
      features: [
        {
          title: "Readiness Monitoring",
          description:
            "Daily assessments of athlete readiness based on sleep, soreness, and subjective wellness metrics.",
        },
        {
          title: "Load Management",
          description: "Tracking of acute and chronic training loads to optimize performance and reduce injury risk.",
        },
        {
          title: "Performance Trending",
          description: "Visualization of key performance indicators over time to identify patterns and progress.",
        },
        {
          title: "Customizable Metrics",
          description: "Ability to tailor tracked metrics to specific sports and individual athlete needs.",
        },
      ],
      youtubeId: "dQw4w9WgXcQ",
      content: "Sample content for Performance Analytics Dashboard",
    },
  ]
}

